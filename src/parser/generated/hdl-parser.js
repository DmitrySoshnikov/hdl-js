/**
 * LR parser generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/path-to-output-parser-file.js
 */

'use strict';

/**
 * Matched token text.
 */
let yytext;

/**
 * Length of the matched token text.
 */
let yyleng;

/**
 * Storage object.
 */
let yy = {};

/**
 * Result of semantic action.
 */
let __;

/**
 * Result location object.
 */
let __loc;

function yyloc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  // Epsilon doesn't produce location.
  if (!start || !end) {
    return start || end;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn,
  };
}

const EOF = '$';

/**
 * List of productions (generated by Syntax tool).
 */
const productions = [
  [
    -1,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    0,
    5,
    (_1, _2, _3, _4, _5, _1loc, _2loc, _3loc, _4loc, _5loc) => {
      __loc = yyloc(_1loc, _5loc);
      __ = {
        type: 'Chip',
        name: _2,
        inputs,
        outputs,
        parts,
        builtins,
        clocked,
      };
    },
  ],
  [
    1,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [1, 2],
  [
    2,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    2,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    2,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    2,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    2,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    3,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      inputs.push(...subscriptListToProp(_2, 'size'));
    },
  ],
  [
    4,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      outputs.push(...subscriptListToProp(_2, 'size'));
    },
  ],
  [
    5,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      parts.push(..._3);
    },
  ],
  [
    6,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      builtins.push(..._2);
    },
  ],
  [
    7,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      clocked.push(..._2);
    },
  ],
  [
    8,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = [_1];
    },
  ],
  [
    8,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      _1.push(_3);
      __ = _1;
    },
  ],
  [
    9,
    2,
    (_1, _2, _1loc, _2loc) => {
      __loc = yyloc(_1loc, _2loc);
      __ = {
        type: 'Name',
        value: _1,
      };

      if (_2) {
        __.subscript = _2;
      }
    },
  ],
  [
    10,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [10, 0],
  [
    11,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      __ = _2;
    },
  ],
  [
    12,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = {
        kind: 'number',
        value: Number(_1),
      };
    },
  ],
  [
    12,
    4,
    (_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) => {
      __loc = yyloc(_1loc, _4loc);
      __ = {
        kind: 'range',
        from: Number(_1),
        to: Number(_4),
      };
    },
  ],
  [
    13,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    13,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    14,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    15,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    15,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    15,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    15,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    15,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    15,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    16,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = [_1];
    },
  ],
  [
    16,
    2,
    (_1, _2, _1loc, _2loc) => {
      __loc = yyloc(_1loc, _2loc);
      _1.push(_2);
      __ = _1;
    },
  ],
  [
    17,
    5,
    (_1, _2, _3, _4, _5, _1loc, _2loc, _3loc, _4loc, _5loc) => {
      __loc = yyloc(_1loc, _5loc);
      __ = {
        type: 'ChipCall',
        name: _1,
        arguments: _3,
      };
    },
  ],
  [
    18,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = [_1];
    },
  ],
  [
    18,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      _1.push(_3);
      __ = _1;
    },
  ],
  [
    19,
    3,
    (_1, _2, _3, _1loc, _2loc, _3loc) => {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        type: 'Argument',
        name: subscriptToProp(_1, 'index'),
        value: subscriptToProp(_3, 'index'),
      };
    },
  ],
  [
    20,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    },
  ],
  [
    20,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      let constName = null;
      if (_1.value === 'true') {
        constName = 1;
      } else if (_1.value === 'false') {
        constName = 0;
      }

      if (constName !== null) {
        __ = {
          type: 'Constant',
          value: constName,
          raw: _1.value,
        };
      } else {
        // Other name:
        __ = _1;
      }
    },
  ],
  [
    21,
    1,
    (_1, _1loc) => {
      __loc = yyloc(_1loc, _1loc);
      __ = {
        type: 'Constant',
        value: Number(_1),
        raw: _1,
      };
    },
  ],
];

/**
 * Encoded tokens map.
 */
const tokens = {
  CHIP: '22',
  IN: '23',
  OUT: '24',
  PARTS: '25',
  BUILTIN: '26',
  CLOCKED: '27',
  NUMBER: '28',
  ID: '29',
  "'{'": '30',
  "'}'": '31',
  "';'": '32',
  "':'": '33',
  "','": '34',
  "'['": '35',
  "']'": '36',
  "'.'": '37',
  "'('": '38',
  "')'": '39',
  "'='": '40',
  $: '41',
};

/**
 * Parsing table (generated by Syntax tool).
 */
const table = [
  {'0': 63, '22': 's1'},
  {'14': 2, '29': 's64'},
  {'30': 's3'},
  {
    '1': 4,
    '2': 5,
    '3': 6,
    '4': 7,
    '5': 8,
    '6': 9,
    '7': 10,
    '23': 's11',
    '24': 's12',
    '25': 's13',
    '26': 's14',
    '27': 's15',
  },
  {
    '2': 16,
    '3': 6,
    '4': 7,
    '5': 8,
    '6': 9,
    '7': 10,
    '23': 's11',
    '24': 's12',
    '25': 's13',
    '26': 's14',
    '27': 's15',
    '31': 's65',
  },
  {'23': 'r2', '24': 'r2', '25': 'r2', '26': 'r2', '27': 'r2', '31': 'r2'},
  {'23': 'r4', '24': 'r4', '25': 'r4', '26': 'r4', '27': 'r4', '31': 'r4'},
  {'23': 'r5', '24': 'r5', '25': 'r5', '26': 'r5', '27': 'r5', '31': 'r5'},
  {'23': 'r6', '24': 'r6', '25': 'r6', '26': 'r6', '27': 'r6', '31': 'r6'},
  {'23': 'r7', '24': 'r7', '25': 'r7', '26': 'r7', '27': 'r7', '31': 'r7'},
  {'23': 'r8', '24': 'r8', '25': 'r8', '26': 'r8', '27': 'r8', '31': 'r8'},
  {
    '8': 17,
    '9': 18,
    '13': 19,
    '15': 21,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '29': 's20',
  },
  {
    '8': 39,
    '9': 18,
    '13': 19,
    '15': 21,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '29': 's20',
  },
  {'33': 's41'},
  {
    '8': 59,
    '9': 18,
    '13': 19,
    '15': 21,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '29': 's20',
  },
  {
    '8': 61,
    '9': 18,
    '13': 19,
    '15': 21,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '29': 's20',
  },
  {'23': 'r3', '24': 'r3', '25': 'r3', '26': 'r3', '27': 'r3', '31': 'r3'},
  {'32': 's28', '34': 's29'},
  {'32': 'r14', '34': 'r14'},
  {
    '10': 31,
    '11': 32,
    '32': 'r18',
    '34': 'r18',
    '35': 's33',
    '39': 'r18',
    '40': 'r18',
  },
  {'32': 'r22', '34': 'r22', '35': 'r22', '39': 'r22', '40': 'r22'},
  {'32': 'r23', '34': 'r23', '35': 'r23', '39': 'r23', '40': 'r23'},
  {'32': 'r25', '34': 'r25', '35': 'r25', '39': 'r25', '40': 'r25'},
  {'32': 'r26', '34': 'r26', '35': 'r26', '39': 'r26', '40': 'r26'},
  {'32': 'r27', '34': 'r27', '35': 'r27', '39': 'r27', '40': 'r27'},
  {'32': 'r28', '34': 'r28', '35': 'r28', '39': 'r28', '40': 'r28'},
  {'32': 'r29', '34': 'r29', '35': 'r29', '39': 'r29', '40': 'r29'},
  {'32': 'r30', '34': 'r30', '35': 'r30', '39': 'r30', '40': 'r30'},
  {'23': 'r9', '24': 'r9', '25': 'r9', '26': 'r9', '27': 'r9', '31': 'r9'},
  {
    '9': 30,
    '13': 19,
    '15': 21,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '29': 's20',
  },
  {'32': 'r15', '34': 'r15'},
  {'32': 'r16', '34': 'r16', '39': 'r16', '40': 'r16'},
  {'32': 'r17', '34': 'r17', '39': 'r17', '40': 'r17'},
  {'12': 34, '28': 's35'},
  {'36': 's36'},
  {'36': 'r20', '37': 's37'},
  {'32': 'r19', '34': 'r19', '39': 'r19', '40': 'r19'},
  {'37': 's38'},
  {'28': 's66'},
  {'32': 's40', '34': 's29'},
  {
    '23': 'r10',
    '24': 'r10',
    '25': 'r10',
    '26': 'r10',
    '27': 'r10',
    '31': 'r10',
  },
  {'14': 44, '16': 42, '17': 43, '29': 's64'},
  {
    '14': 44,
    '17': 45,
    '23': 'r11',
    '24': 'r11',
    '25': 'r11',
    '26': 'r11',
    '27': 'r11',
    '29': 's64',
    '31': 'r11',
  },
  {
    '23': 'r31',
    '24': 'r31',
    '25': 'r31',
    '26': 'r31',
    '27': 'r31',
    '29': 'r31',
    '31': 'r31',
  },
  {'38': 's46'},
  {
    '23': 'r32',
    '24': 'r32',
    '25': 'r32',
    '26': 'r32',
    '27': 'r32',
    '29': 'r32',
    '31': 'r32',
  },
  {
    '9': 49,
    '13': 19,
    '15': 21,
    '18': 47,
    '19': 48,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '29': 's20',
  },
  {'34': 's51', '39': 's50'},
  {'34': 'r34', '39': 'r34'},
  {'40': 's54'},
  {'32': 's52'},
  {
    '9': 49,
    '13': 19,
    '15': 21,
    '19': 53,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '29': 's20',
  },
  {
    '23': 'r33',
    '24': 'r33',
    '25': 'r33',
    '26': 'r33',
    '27': 'r33',
    '29': 'r33',
    '31': 'r33',
  },
  {'34': 'r35', '39': 'r35'},
  {
    '9': 57,
    '13': 19,
    '15': 21,
    '20': 55,
    '21': 56,
    '22': 's22',
    '23': 's23',
    '24': 's24',
    '25': 's25',
    '26': 's26',
    '27': 's27',
    '28': 's58',
    '29': 's20',
  },
  {'34': 'r36', '39': 'r36'},
  {'34': 'r37', '39': 'r37'},
  {'34': 'r38', '39': 'r38'},
  {'34': 'r39', '39': 'r39'},
  {'32': 's60', '34': 's29'},
  {
    '23': 'r12',
    '24': 'r12',
    '25': 'r12',
    '26': 'r12',
    '27': 'r12',
    '31': 'r12',
  },
  {'32': 's62', '34': 's29'},
  {
    '23': 'r13',
    '24': 'r13',
    '25': 'r13',
    '26': 'r13',
    '27': 'r13',
    '31': 'r13',
  },
  {'41': 'acc'},
  {'30': 'r24', '38': 'r24'},
  {'41': 'r1'},
  {'36': 'r21'},
];

/**
 * Parsing stack.
 */
const stack = [];

/**
 * Tokenizer instance.
 */
let tokenizer;
/**
 * Generic tokenizer used by the parser in the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 * See `--custom-tokinzer` to skip this generation, and use a custom one.
 */

const lexRules = [
  [
    /^\/\/.*/,
    function() {
      /* skip comments */
    },
  ],
  [
    /^\/\*(.|\s)*?\*\//,
    function() {
      /* skip comments */
    },
  ],
  [
    /^\s+/,
    function() {
      /* skip whitespace */
    },
  ],
  [
    /^\b(?:CHIP|chip)\b/,
    function() {
      return 'CHIP';
    },
  ],
  [
    /^\b(?:IN|in)\b/,
    function() {
      return 'IN';
    },
  ],
  [
    /^\b(?:OUT|out)\b/,
    function() {
      return 'OUT';
    },
  ],
  [
    /^\b(?:PARTS|parts)\b/,
    function() {
      return 'PARTS';
    },
  ],
  [
    /^\b(?:BUILTIN|builtin)\b/,
    function() {
      return 'BUILTIN';
    },
  ],
  [
    /^\b(?:CLOCKED|clocked)\b/,
    function() {
      return 'CLOCKED';
    },
  ],
  [
    /^\d+/,
    function() {
      return 'NUMBER';
    },
  ],
  [
    /^[a-zA-Z_$]\w*/,
    function() {
      return 'ID';
    },
  ],
  [
    /^\{/,
    function() {
      return "'{'";
    },
  ],
  [
    /^\}/,
    function() {
      return "'}'";
    },
  ],
  [
    /^;/,
    function() {
      return "';'";
    },
  ],
  [
    /^:/,
    function() {
      return "':'";
    },
  ],
  [
    /^,/,
    function() {
      return "','";
    },
  ],
  [
    /^\[/,
    function() {
      return "'['";
    },
  ],
  [
    /^\]/,
    function() {
      return "']'";
    },
  ],
  [
    /^\./,
    function() {
      return "'.'";
    },
  ],
  [
    /^\(/,
    function() {
      return "'('";
    },
  ],
  [
    /^\)/,
    function() {
      return "')'";
    },
  ],
  [
    /^=/,
    function() {
      return "'='";
    },
  ],
];
const lexRulesByConditions = {
  INITIAL: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
  ],
};

const EOF_TOKEN = {
  type: EOF,
  value: '',
};

tokenizer = {
  initString(string) {
    this._string = string;
    this._cursor = 0;

    this._states = ['INITIAL'];
    this._tokensQueue = [];

    this._currentLine = 1;
    this._currentColumn = 0;
    this._currentLineBeginOffset = 0;

    /**
     * Matched token location data.
     */
    this._tokenStartOffset = 0;
    this._tokenEndOffset = 0;
    this._tokenStartLine = 1;
    this._tokenEndLine = 1;
    this._tokenStartColumn = 0;
    this._tokenEndColumn = 0;

    return this;
  },

  /**
   * Returns tokenizer states.
   */
  getStates() {
    return this._states;
  },

  getCurrentState() {
    return this._states[this._states.length - 1];
  },

  pushState(state) {
    this._states.push(state);
  },

  begin(state) {
    this.pushState(state);
  },

  popState() {
    if (this._states.length > 1) {
      return this._states.pop();
    }
    return this._states[0];
  },

  getNextToken() {
    // Something was queued, return it.
    if (this._tokensQueue.length > 0) {
      return this._toToken(this._tokensQueue.shift());
    }

    if (!this.hasMoreTokens()) {
      return EOF_TOKEN;
    }

    let string = this._string.slice(this._cursor);
    let lexRulesForState = lexRulesByConditions[this.getCurrentState()];

    for (let i = 0; i < lexRulesForState.length; i++) {
      let lexRuleIndex = lexRulesForState[i];
      let lexRule = lexRules[lexRuleIndex];

      let matched = this._match(string, lexRule[0]);

      // Manual handling of EOF token (the end of string). Return it
      // as `EOF` symbol.
      if (string === '' && matched === '') {
        this._cursor++;
      }

      if (matched !== null) {
        yytext = matched;
        yyleng = yytext.length;
        let token = lexRule[1].call(this);

        if (!token) {
          return this.getNextToken();
        }

        // If multiple tokens are returned, save them to return
        // on next `getNextToken` call.

        if (Array.isArray(token)) {
          const tokensToQueue = token.slice(1);
          token = token[0];
          if (tokensToQueue.length > 0) {
            this._tokensQueue.unshift(...tokensToQueue);
          }
        }

        return this._toToken(token, yytext);
      }
    }

    if (this.isEOF()) {
      this._cursor++;
      return EOF_TOKEN;
    }

    this.throwUnexpectedToken(
      string[0],
      this._currentLine,
      this._currentColumn
    );
  },

  /**
   * Throws default "Unexpected token" exception, showing the actual
   * line from the source, pointing with the ^ marker to the bad token.
   * In addition, shows `line:column` location.
   */
  throwUnexpectedToken(symbol, line, column) {
    const lineSource = this._string.split('\n')[line - 1];
    let lineData = '';

    if (lineSource) {
      const pad = ' '.repeat(column);
      lineData = '\n\n' + lineSource + '\n' + pad + '^\n';
    }

    throw new SyntaxError(
      `${lineData}Unexpected token: "${symbol}" ` + `at ${line}:${column}.`
    );
  },

  getCursor() {
    return this._cursor;
  },

  getCurrentLine() {
    return this._currentLine;
  },

  getCurrentColumn() {
    return this._currentColumn;
  },

  _captureLocation(matched) {
    const nlRe = /\n/g;

    // Absolute offsets.
    this._tokenStartOffset = this._cursor;

    // Line-based locations, start.
    this._tokenStartLine = this._currentLine;
    this._tokenStartColumn =
      this._tokenStartOffset - this._currentLineBeginOffset;

    // Extract `\n` in the matched token.
    let nlMatch;
    while ((nlMatch = nlRe.exec(matched)) !== null) {
      this._currentLine++;
      this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
    }

    this._tokenEndOffset = this._cursor + matched.length;

    // Line-based locations, end.
    this._tokenEndLine = this._currentLine;
    this._tokenEndColumn = this._currentColumn =
      this._tokenEndOffset - this._currentLineBeginOffset;
  },

  _toToken(tokenType, yytext = '') {
    return {
      // Basic data.
      type: tokenType,
      value: yytext,

      // Location data.
      startOffset: this._tokenStartOffset,
      endOffset: this._tokenEndOffset,
      startLine: this._tokenStartLine,
      endLine: this._tokenEndLine,
      startColumn: this._tokenStartColumn,
      endColumn: this._tokenEndColumn,
    };
  },

  isEOF() {
    return this._cursor === this._string.length;
  },

  hasMoreTokens() {
    return this._cursor <= this._string.length;
  },

  _match(string, regexp) {
    let matched = string.match(regexp);
    if (matched) {
      // Handle `\n` in the matched token to track line numbers.
      this._captureLocation(matched[0]);
      this._cursor += matched[0].length;
      return matched[0];
    }
    return null;
  },
};

/**
 * Expose tokenizer so it can be accessed in semantic actions.
 */
yy.lexer = tokenizer;
yy.tokenizer = tokenizer;

/**
 * Global parsing options. Some options can be shadowed per
 * each `parse` call, if the optations are passed.
 *
 * Initalized to the `captureLocations` which is passed
 * from the generator. Other options can be added at runtime.
 */
yy.options = {
  captureLocations: true,
};

/**
 * Parsing module.
 */
const yyparse = {
  /**
   * Sets global parsing options.
   */
  setOptions(options) {
    yy.options = options;
    return this;
  },

  /**
   * Returns parsing options.
   */
  getOptions() {
    return yy.options;
  },

  /**
   * Parses a string.
   */
  parse(string, parseOptions) {
    if (!tokenizer) {
      throw new Error(`Tokenizer instance wasn't specified.`);
    }

    tokenizer.initString(string);

    /**
     * If parse options are passed, override global parse options for
     * this call, and later restore global options.
     */
    let globalOptions = yy.options;
    if (parseOptions) {
      yy.options = Object.assign({}, yy.options, parseOptions);
    }

    /**
     * Allow callers to do setup work based on the
     * parsing string, and passed options.
     */
    yyparse.onParseBegin(string, tokenizer, yy.options);

    stack.length = 0;
    stack.push(0);

    let token = tokenizer.getNextToken();
    let shiftedToken = null;

    do {
      if (!token) {
        // Restore options.
        yy.options = globalOptions;
        unexpectedEndOfInput();
      }

      let state = stack[stack.length - 1];
      let column = tokens[token.type];

      if (!table[state].hasOwnProperty(column)) {
        yy.options = globalOptions;
        unexpectedToken(token);
      }

      let entry = table[state][column];

      // Shift action.
      if (entry[0] === 's') {
        let loc = null;

        if (yy.options.captureLocations) {
          loc = {
            startOffset: token.startOffset,
            endOffset: token.endOffset,
            startLine: token.startLine,
            endLine: token.endLine,
            startColumn: token.startColumn,
            endColumn: token.endColumn,
          };
        }

        stack.push(
          {symbol: tokens[token.type], semanticValue: token.value, loc},
          Number(entry.slice(1))
        );
        shiftedToken = token;
        token = tokenizer.getNextToken();
      } else if (entry[0] === 'r') {
        // Reduce action.
        let productionNumber = entry.slice(1);
        let production = productions[productionNumber];
        let hasSemanticAction = typeof production[2] === 'function';
        let semanticValueArgs = hasSemanticAction ? [] : null;

        const locationArgs =
          hasSemanticAction && yy.options.captureLocations ? [] : null;

        if (production[1] !== 0) {
          let rhsLength = production[1];
          while (rhsLength-- > 0) {
            stack.pop();
            let stackEntry = stack.pop();

            if (hasSemanticAction) {
              semanticValueArgs.unshift(stackEntry.semanticValue);

              if (locationArgs) {
                locationArgs.unshift(stackEntry.loc);
              }
            }
          }
        }

        const reduceStackEntry = {symbol: production[0]};

        if (hasSemanticAction) {
          yytext = shiftedToken ? shiftedToken.value : null;
          yyleng = shiftedToken ? shiftedToken.value.length : null;

          const semanticActionArgs =
            locationArgs !== null
              ? semanticValueArgs.concat(locationArgs)
              : semanticValueArgs;

          production[2](...semanticActionArgs);

          reduceStackEntry.semanticValue = __;

          if (locationArgs) {
            reduceStackEntry.loc = __loc;
          }
        }

        const nextState = stack[stack.length - 1];
        const symbolToReduceWith = production[0];

        stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);
      } else if (entry === 'acc') {
        // Accept.
        stack.pop();
        let parsed = stack.pop();

        if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {
          // Restore options.
          yy.options = globalOptions;
          unexpectedToken(token);
        }

        if (parsed.hasOwnProperty('semanticValue')) {
          yy.options = globalOptions;
          yyparse.onParseEnd(parsed.semanticValue);
          return parsed.semanticValue;
        }

        yyparse.onParseEnd();

        // Restore options.
        yy.options = globalOptions;
        return true;
      }
    } while (tokenizer.hasMoreTokens() || stack.length > 1);
  },

  setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return yyparse;
  },

  getTokenizer() {
    return tokenizer;
  },

  onParseBegin(string, tokenizer, options) {},
  onParseEnd(parsed) {},
};

/**
 * List of inputs for this chip.
 */
let inputs = null;

/**
 * List of outputs for this chip.
 */
let outputs = null;

/**
 * Actual definitions.
 */
let parts = null;

/**
 * Builtin parts.
 */
let builtins = null;

/**
 * Clocked parts.
 */
let clocked = null;

yyparse.onParseBegin = _string => {
  inputs = [];
  outputs = [];
  parts = [];
  builtins = [];
  clocked = [];
};

/**
 * Converts subscript to `size` for input/ouput:
 * `a[16]`: {value: 'a', size: 16}
 *
 * And to `index` or `range` for references:
 * `a[15]`: {value: 'a', index: 15}
 * `a[0..7]`: {value: 'a', range: {from: 0, to: 7}}
 */
function subscriptToProp(value, prop) {
  const {subscript} = value;

  if (subscript) {
    if (subscript.kind === 'number') {
      value[prop] = subscript.value;
    } else if (subscript.kind === 'range') {
      delete subscript.kind;
      value.range = subscript;
    }
    delete value.subscript;
  }

  return value;
}

function subscriptListToProp(values, prop) {
  values.forEach(value => subscriptToProp(value, prop));
  return values;
}

function unexpectedToken(token) {
  if (token.type === EOF) {
    unexpectedEndOfInput();
  }

  tokenizer.throwUnexpectedToken(
    token.value,
    token.startLine,
    token.startColumn
  );
}

function unexpectedEndOfInput() {
  parseError(`Unexpected end of input.`);
}

function parseError(message) {
  throw new SyntaxError(message);
}

module.exports = yyparse;
