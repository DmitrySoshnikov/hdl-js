/**
 * The MIT License (MIT)
 * Copyright (c) 2017-present Dmitry Soshnikov <dmitry.soshnikov@gmail.com>
 */

'use strict';

/**
 * Helper `gen` function calls node type handler.
 */
function gen(node) {
  return node ? generator[node.type](node) : '';
}

/**
 * Generates input pins.
 */
function genInputs(inputs) {
  return `IN ${inputs.map(gen).join(', ')};`;
}

/**
 * Generates output pins.
 */
function genOutputs(outputs) {
  return `OUT ${outputs.map(gen).join(', ')};`;
}

/**
 * Generates parts implementation.
 */
function genParts(parts) {
  if (!parts || parts.length === 0) {
    return '';
  }

  return `

    PARTS:

    ${parts.map(gen).join(';\n')};`;
}

/**
 * Generates builtin chips list.
 */
function genBuiltins(builtins) {
  if (!builtins || builtins.length === 0) {
    return '';
  }

  return `

    BUILTIN ${builtins.map(gen).join(', ')};`;
}

/**
 * Generates clocked pins.
 */
function genClocked(clocked) {
  if (!clocked || clocked.length === 0) {
    return '';
  }

  return `

    CLOCKED ${clocked.map(gen).join(', ')};`;
}

/**
 * AST handler.
 */
const generator = {
  Chip(node) {
    return `
      CHIP ${node.name} {
        ${genInputs(node.inputs)}
        ${genOutputs(node.outputs)}` +

        // Optional parts:
        genParts(node.parts) +
        genBuiltins(node.builtins) +
        genClocked(node.clocked) + `
      }
    `;
  },

  Name(node) {
    const name = node.value;

    // a[1]
    if (node.hasOwnProperty('index')) {
      return `${name}[${node.index}]`;
    }

    // a[1]
    if (node.hasOwnProperty('size')) {
      return `${name}[${node.size}]`;
    }

    // a[0..3]
    if (node.hasOwnProperty('range')) {
      return `${name}[${node.range.from}..${node.range.to}]`;
    }

    // a
    return name;
  },

  ChipCall(node) {
    const args = node.arguments
      .map(gen)
      .join(', ');

    return `${node.name}(${args})`;
  },

  Argument(node) {
    return `${gen(node.name)}=${gen(node.value)}`;
  }
};

/**
 * Reformats the code according to options.
 */
function reformat(code, {indent = 2} = {}) {
  return code
    .trim()
    .split('\n')
    .map((line, index, arr) => {
      line = line.trim();
      if (line && index > 0 && index < arr.length - 1) {
        line = ' '.repeat(indent) + line;
      }
      return line;
    })
    .join('\n');
}

module.exports = {
  /**
   * Generates an HDL code from AST.
   *
   * options: {indent = 2}
   */
  fromAST(node, options) {
    const hdl = reformat(gen(node), options);
    return [
      `/**`,
      ` * Automatically generated by hdl-js "${node.name}" gate.`,
      ` */`,
      hdl,
    ].join('\n');
  },

  /**
   * Generates an HDL code from a CompositeGate instance.
   *
   * options: see `generateFromAST`.
   */
  fromCompositeGate(compositeGate, options) {
    return this.fromAST(compositeGate.toAST(), options);
  },
};